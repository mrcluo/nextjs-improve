## 简介

- 零配置
  - 自动编译并打包。不需要开发者再进行项目配置,从一开始就为生产环境而优化。
- 混合模式: SSG和SSR
  - 在一个项目中同时支持构建时预渲染页面(SSG）和请求时渲染页面(SSR)
- 增量静态生成
  - 在构建之后以增量的方式添加并更新静态预渲染的页面。
- 支持TypeScript
  - 自动配置并编译TypeScript
- 快速刷新
  - 快速、可靠的实时编辑体验，已在Facebook级别的应用上规模上得到验证。
- 基于文件系统的路由
  - nextjs的每个pages目录下的组件都是—条路由,比较友好。
  - CRA框架还要去通过react-router 去构建路由
- API路由
  - 创建API端点(可选)以提供后端功能。
- 内置支持CSS
  - 使用CSS模块创建组件级的样式。内置对Sass的支持。
- 代码拆分和打包
  - 采用由Google Chrome小组创建的、并经过优化的打包和拆分算法。


## SSR SSG和CSR应用场景
SSR: 需要SEO, 首屏展示需要快一点, 会增加服务端压力, 但是会让客户感觉网页性能好
SSG: 需要SEO, 首屏展示需要更快一点, 不会增加服务端压力, 但是是静态页面(动态数据比较频繁的场景不友好)
CSR: 不需要SEO

## 特殊场景: CSR和SSR自动匹配
Prerender(预渲染): 爬虫和低端手机的用户走SSR, 用户和高端手机的用户走CSR

## ssr渲染
客户端 => node中间层 => 服务器
优点: 客户端向node中间层发起资源请求, node层和服务端交互后返回有内容的html(首屏html css js)给客户端
node中间层和服务器之间基本没有延时(它两基本在一个内网), 但是, 客户端直接和服务器交互有延时


## csr渲染
客户端 =>服务器
客户端向服务器发起资源请求,服务端返回空的html, 读取html的script 再次像服务端请求, 拿到所有数据进行渲染


## SSR 和 SSG
SSR: 每次路径变化重新请求, 都经过node中间件渲染页面
SSG: 本质上基于ssr服务,加了个缓存.   对于任何一个路径,可以把ssr生成的结果缓存起来,返回给客户端,
- SSG: 张三和李四都访问路径A, 张三访问路径A后, ssr生成的结果缓存, 李四访问路径A直接看到的是缓存的页面
- SSR: 张三和李四访问路径A, 两个人看的页面都是重新生成的(一定程度对性能优化不太友好)

## ISR(实质是SSG + SSR)
重新生成静态页面,避免有些静态页面展示不了新数据
举例, 你的个人主页做了SSG, 对应路径是一个静态页面. 当你有新文章的时候,这个页面却不展示你的文章
可以使用ISR 60秒更新一次你的个人主页

静态内容走SSG
动态内容走SSR

## BFF和SSR的关联
都是node中间层的优化
SSR(下图黄框)侧重在node中间层返回有内容的html
BFF(下图篮框)侧重在node中间层聚合业务接口, 比如聚合十个业务接口和服务端交互,返回数据给客户端 

## 迁移
CSR项目迁移nextjs成本不是很大
JS项目迁移TS项目成本不是很大

## 安装
nextjs项目
```js
npx create-next-app@latest --typescript
```

普通react项目
```js
npx create-react-app my-react-app
```